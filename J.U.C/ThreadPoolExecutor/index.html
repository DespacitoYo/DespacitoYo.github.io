<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>ThreadPoolExecutor | DespacitoYo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="DespacitoYo's Blog">
  
  <meta name="description" content="1 创建线程池（ThreadPoolExecutor）ThreadPollExecutor有四个构造函数，但本质上都是调用这一个构造函数。 123456789public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long k">
<meta property="og:type" content="article">
<meta property="og:title" content="ThreadPoolExecutor">
<meta property="og:url" content="DespacitoYo.github.io/J.U.C/ThreadPoolExecutor/index.html">
<meta property="og:site_name" content="DespacitoYo">
<meta property="og:description" content="1 创建线程池（ThreadPoolExecutor）ThreadPollExecutor有四个构造函数，但本质上都是调用这一个构造函数。 123456789public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long k">
<meta property="og:locale" content="default">
<meta property="og:image" content="DespacitoYo.github.io/J.U.C/ThreadPoolExecutor/ThreadPool.jpg">
<meta property="og:updated_time" content="2019-07-10T09:58:31.353Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ThreadPoolExecutor">
<meta name="twitter:description" content="1 创建线程池（ThreadPoolExecutor）ThreadPollExecutor有四个构造函数，但本质上都是调用这一个构造函数。 123456789public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long k">
<meta name="twitter:image" content="DespacitoYo.github.io/J.U.C/ThreadPoolExecutor/ThreadPool.jpg">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>
  

  
  

</head>
</html>
<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">DespacitoYo&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        DespacitoYo&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        心之所向，即为远方
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Despacito" target="_blank" href="/">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/despacitoyo">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-ThreadPoolExecutor" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      ThreadPoolExecutor
    </h1>
    <div class="post-title-bar">
      <ul>
          
        <li>
          <i class="fa fa-calendar"></i>  2019-07-04
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h2 id="1-创建线程池（ThreadPoolExecutor）"><a href="#1-创建线程池（ThreadPoolExecutor）" class="headerlink" title="1 创建线程池（ThreadPoolExecutor）"></a>1 创建线程池（ThreadPoolExecutor）</h2><p>ThreadPollExecutor有四个构造函数，但本质上都是调用这一个构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>corePoolSize</strong>: 线程池核心线程数量 <br><br><strong>maximumPoolSize</strong>：线程池最大线程数量<br><br><strong>keepAliveTime</strong>：线程空闲时间<br><br><strong>unit</strong>：空闲时间单位<br><br><strong>workQueue</strong>：工作队列，没有空闲线程时新加的任务会放入工作队列中排队等待。工作队列共有四种实现：</p>
<pre><code>a.ArrayBlockingQueue: 创建固定大小的阻塞队列， 采用的是数组的结构方式
b.LinkedBlockingQueue: 创建固定大小的阻塞队列，如果为传入参数，则会创建Integer.MaxValue大小的队列
c.SynchronousQueue: 创建一个不存储元素的阻塞队列，每一个元素的插入都必须等待一个元素的移除操作，不然会一直阻塞。
d.PriorityBlockingQueue: 一个具有优先级的无限阻塞队列。</code></pre><p><strong>threadFactory</strong>：线程工厂，用于创建线程池中的线程，可以自己实现，默认工厂创建的线程名称为-poolNumber-thread-threadNumber，如：pool-1-thread-10<br><br><strong>handler</strong>: 拒绝策略，当线程池线程达到最大后添加任务不能被执行时的处理策略。拒绝策略有4种实现，当然也可以自己实现（继承RejectExecutionHandle）。</p>
<pre><code>a. AbortPolicy：默认拒绝策略，丢弃这个任务并抛出RejectedExecutionException异常
b. DiscardPolicy：直接丢弃，不做任何处理
c. DiscardOldestPolicy：将工作队列头部元素丢弃（最老的），然后重新提交任务
d. CallerRunsPolicy：主线程直接去执行这个任务，不用等待线程池</code></pre><h4 id="Executors工具类提供了几种ThreadpoolExecutor的创建方法："><a href="#Executors工具类提供了几种ThreadpoolExecutor的创建方法：" class="headerlink" title="Executors工具类提供了几种ThreadpoolExecutor的创建方法："></a>Executors工具类提供了几种ThreadpoolExecutor的创建方法：</h4><h5 id="1-FixedThreadPool"><a href="#1-FixedThreadPool" class="headerlink" title="1. FixedThreadPool"></a>1. FixedThreadPool</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FixedThreadPool的corePoolSize和maximumPoolSize都被设置为同一个参数nThreads<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keepAliveTime被设为0L意味着多余的空闲线程会被立即终止<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列容量为Integer.MAX_VALUE）。这意味着当线程池中的线程数达到corePoolSize时，新任务会被放入工作队列，因此线程池中的线程不会超过核心线程数。所以此时maximumPoolSize和keepAliveTime都是无效参数，并且只要线程池在运行中便不会拒绝任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-SingleThreadExecutor"><a href="#2-SingleThreadExecutor" class="headerlink" title="2. SingleThreadExecutor"></a>2. SingleThreadExecutor</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SingleThreadExecutor是一个使用单个worker线程的Executor，它的核心线程数和最大线程数都被设为1，相当于单线程的FixedThreadPool。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-CachedThreadPool"><a href="#3-CachedThreadPool" class="headerlink" title="3. CachedThreadPool"></a>3. CachedThreadPool</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CachedThreadPool是一个会根据需要创建新线程的线程池，它的corePoolSize为0，意味着核心线程为空。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keepAliveTime被设为60L意味着多余的空闲线程会在空闲60s后被终止。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用没有容量的SynchronousQueue作为工作队列，每次offer操作必须等待另一个take操作，反之亦然，SynchronousQueue就像一个门框（门框上不可以站人）。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最大线程数为Integer.MAX_VALUE，意味着当主线程提交任务速度高于线程池中的线程处理速度时，会无限制的创建新线程。极端情况下，会因为创建过多的线程耗尽CPU和内存资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-线程池工作原理"><a href="#2-线程池工作原理" class="headerlink" title="2 线程池工作原理"></a>2 线程池工作原理</h2><pre><code>1. 当一个任务被提交时，线程池会判断核心线程数量是否达到最大，如果没有则会通过线程工厂创建一个新的线程来执行任务；如果达到最大则执行步骤2.
2. 尝试将任务放入工作队列，如果成功加入工作队列，当有工作线程空闲时会去工作队列中获取一个任务来执行；如果加入失败则执行步骤3.
3. 判断线程数量是否已达到最大线程数量，如果没有则会通过线程工厂创建一个新的线程来执行任务；如果已达到最大线程数，则执行拒绝策略   </code></pre><p><img src="ThreadPool.jpg" alt="image"></p>
<h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3 源码分析"></a>3 源码分析</h2><h3 id="3-1-核心静态变量及方法"><a href="#3-1-核心静态变量及方法" class="headerlink" title="3.1 核心静态变量及方法"></a>3.1 核心静态变量及方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高3位表示运行的状态，低29未表示线程池中运行的线程数量。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//Integer的大小为32，Integer.SIZE - 3 = 29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">//1左移29位后减1，高3位全为0，低29位全为1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">//高3位：111 【-1的二进制为32位全为1（取反加1），左移29位后高3位为111】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//高3位：000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//高3位: 001</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//高3位：010</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//高3位：011</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">// CAPACITY取反后高3位全为1，低29位全为0，与运算后c的低29位全为0，保留高3位获取runState</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// CAPACITY高3位全为0，低29位全为1，与运算后c的高3位全为0，保留低29位获取线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-入口方法（execute）"><a href="#3-2-入口方法（execute）" class="headerlink" title="3.2 入口方法（execute）"></a>3.2 入口方法（execute）</h3><ol>
<li>如果工作线程未达到核心线程数，直接创建一个工作线程来执行任务，创建失败则继续执行下一步。</li>
<li>如果线程池正在运行中并且将任务加入工作队列成功，则进行安全检查，虽然加入工作队列成功，但是保不齐其他调用者或者线程此时会修改线程池状态，那么此时我们就需要将任务再进行必要的移除，这是考虑复杂情况的一种安全机制的保障。</li>
<li>如果加入队列失败，工作线程未达到最大线程数，则创建一个新的线程来执行任务，工作线程已达到最大线程数则执行拒绝策略<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//高3位表示运行的状态，低29未表示线程池中运行的线程数量。</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//根据低29位获取线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//如果工作线程数量小于核心线程数，尝试创建新的worker线程来执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果失败可能是在addWorker时ctl发生改变（核心线程数达到最大），所以重新获取值</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果线程池正在运行中并且将任务加入工作队列成功</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//如果此刻线程池已不在运行并且任务从队列移除成功，执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//如果此刻线程池还在运行，但是工作线程数量为0，则增加一个空的工作线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果加入队列失败，工作线程未达到最大线程数，则创建一个新的线程来执行任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">//工作线程已达到最大线程数，执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-3-增加工作线程（addWorker）"><a href="#3-3-增加工作线程（addWorker）" class="headerlink" title="3.3 增加工作线程（addWorker）"></a>3.3 增加工作线程（addWorker）</h3><p>首先通过CAS操作增加工作线程数量，增加成功后实例化一个工作线程用来执行任务，然后将工作线程加入works，因为works实际上是一个非线程安全的容器（HashSet），所以通过可重入锁（ReentrantLock）来保证了线程安全问题，防止多个任务同时提交导致works计算不准确，如果添加成功则将该工作线程启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//continue retry; 可以使retry：后面的代码块重新执行</span></span><br><span class="line">    <span class="comment">//break retry; 可以使retry：后面的代码块终止执行，不管有多少层循环嵌套</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//高3位表示运行的状态，低29未表示线程池中运行的线程数量。</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//获取线程池的运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取工作线程数量</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">//如果工作线程数超过限制，则返回添加失败</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//通过CAS机制增加工作线程数，成功则直接跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">//如果CAS操作失败，则说明其他调用者或者线程修改了线程池数据，需要重新读取</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">//如果当前线程池状态已经发生了改变，则从最外层循环开始重新执行</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// 否则继续当前循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//工作线程启动状态</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//工作线程添加状态</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//工作线程引用</span></span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//实例化一个工作线程用于执行任务</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="comment">//取工作线程中的线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取可重入锁</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            <span class="comment">//加锁，防止多个线程同时提交任务导致works计算不准确，因为works实际上使用HashSet存储的，非线程安全的</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取线程池运行状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果线程池处于运行状态</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    <span class="comment">//或者终止状态并且任务为空</span></span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">//如果该线程已运行，则抛出IllegalThreadStateException异常</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">//将新建的工作线程加入works</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    <span class="comment">//调整工作线程添加状态为true</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果工作线程已添加，则启动该线程，并将工作线程启动状态改为true</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果工作线程未启动，执行添加失败逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2019年07月10日 17:58</p>
        <p>原始链接： <a class="post-url" href="/J.U.C/ThreadPoolExecutor/" title="ThreadPoolExecutor">DespacitoYo.github.io/J.U.C/ThreadPoolExecutor/</a></p>
        <footer>
            <a href="DespacitoYo.github.io">
                <img src="/images/logo.png" alt="DespacitoYo">
                DespacitoYo
            </a>
        </footer>
    </div>
</div>

      
        
            

        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=DespacitoYo.github.io/J.U.C/ThreadPoolExecutor/&title=《ThreadPoolExecutor》 — DespacitoYo&pic=https://despacitoyo.github.io/J.U.C/ThreadPoolExecutor/ThreadPool.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=DespacitoYo.github.io/J.U.C/ThreadPoolExecutor/&title=《ThreadPoolExecutor》 — DespacitoYo&source=" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=DespacitoYo.github.io/J.U.C/ThreadPoolExecutor/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《ThreadPoolExecutor》 — DespacitoYo&url=DespacitoYo.github.io/J.U.C/ThreadPoolExecutor/&via=DespacitoYo.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=DespacitoYo.github.io/J.U.C/ThreadPoolExecutor/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=DespacitoYo.github.io/J.U.C/ThreadPoolExecutor/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-创建线程池（ThreadPoolExecutor）"><span class="post-toc-text">1 创建线程池（ThreadPoolExecutor）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Executors工具类提供了几种ThreadpoolExecutor的创建方法："><span class="post-toc-text">Executors工具类提供了几种ThreadpoolExecutor的创建方法：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1-FixedThreadPool"><span class="post-toc-text">1. FixedThreadPool</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-SingleThreadExecutor"><span class="post-toc-text">2. SingleThreadExecutor</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3-CachedThreadPool"><span class="post-toc-text">3. CachedThreadPool</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-线程池工作原理"><span class="post-toc-text">2 线程池工作原理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-源码分析"><span class="post-toc-text">3 源码分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-核心静态变量及方法"><span class="post-toc-text">3.1 核心静态变量及方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-入口方法（execute）"><span class="post-toc-text">3.2 入口方法（execute）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-增加工作线程（addWorker）"><span class="post-toc-text">3.3 增加工作线程（addWorker）</span></a></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/J.U.C/ScheduledThreadPoolExecutor/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          ScheduledThreadPoolExecutor
        
      </span>
    </a>
  
  
</nav>



    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2019 DespacitoYo<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "DespacitoYo.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 0
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            
        </div>
        <div id="sidebar-menu-box-tags">
            
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>
<script src="/js/search.js"></script>
<script src="/js/main.js"></script>


  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  <script src="/js/particles.js"></script>







  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  <script src="/js/animate.js"></script>


  <script src="/js/pop-img.js"></script>
  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>