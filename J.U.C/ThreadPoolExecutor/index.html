<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>ThreadPoolExecutor | DespacitoYo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="DespacitoYo's Blog">
  
  <meta name="description" content="1 创建线程池（ThreadPoolExecutor）ThreadPollExecutor有四个构造函数，但本质上都是调用这一个构造函数。 public ThreadPoolExecutor(int corePoolSize,                           int maximumPoolSize,                           long keepAliv">
<meta property="og:type" content="article">
<meta property="og:title" content="ThreadPoolExecutor">
<meta property="og:url" content="despacitoyo.github.io/J.U.C/ThreadPoolExecutor/index.html">
<meta property="og:site_name" content="DespacitoYo">
<meta property="og:description" content="1 创建线程池（ThreadPoolExecutor）ThreadPollExecutor有四个构造函数，但本质上都是调用这一个构造函数。 public ThreadPoolExecutor(int corePoolSize,                           int maximumPoolSize,                           long keepAliv">
<meta property="og:locale" content="default">
<meta property="og:image" content="despacitoyo.github.io/J.U.C/ThreadPoolExecutor/ThreadPool.jpg">
<meta property="og:updated_time" content="2019-07-10T09:39:35.131Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ThreadPoolExecutor">
<meta name="twitter:description" content="1 创建线程池（ThreadPoolExecutor）ThreadPollExecutor有四个构造函数，但本质上都是调用这一个构造函数。 public ThreadPoolExecutor(int corePoolSize,                           int maximumPoolSize,                           long keepAliv">
<meta name="twitter:image" content="despacitoyo.github.io/J.U.C/ThreadPoolExecutor/ThreadPool.jpg">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>
  

  
  

</head>
</html>
<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">DespacitoYo&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        DespacitoYo&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        心之所向，即为远方
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Despacito" target="_blank" href="/">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/despacitoyo">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-ThreadPoolExecutor" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      ThreadPoolExecutor
    </h1>
    <div class="post-title-bar">
      <ul>
          
        <li>
          <i class="fa fa-calendar"></i>  2019-07-04
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h2 id="1-创建线程池（ThreadPoolExecutor）"><a href="#1-创建线程池（ThreadPoolExecutor）" class="headerlink" title="1 创建线程池（ThreadPoolExecutor）"></a>1 创建线程池（ThreadPoolExecutor）</h2><p>ThreadPollExecutor有四个构造函数，但本质上都是调用这一个构造函数。</p>
<pre><code>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    ...
}</code></pre><p><strong>corePoolSize</strong>: 线程池核心线程数量 <br><br><strong>maximumPoolSize</strong>：线程池最大线程数量<br><br><strong>keepAliveTime</strong>：线程空闲时间<br><br><strong>unit</strong>：空闲时间单位<br><br><strong>workQueue</strong>：工作队列，没有空闲线程时新加的任务会放入工作队列中排队等待。工作队列共有四种实现：</p>
<pre><code>a.ArrayBlockingQueue: 创建固定大小的阻塞队列， 采用的是数组的结构方式
b.LinkedBlockingQueue: 创建固定大小的阻塞队列，如果为传入参数，则会创建Integer.MaxValue大小的队列
c.SynchronousQueue: 创建一个不存储元素的阻塞队列，每一个元素的插入都必须等待一个元素的移除操作，不然会一直阻塞。
d.PriorityBlockingQueue: 一个具有优先级的无限阻塞队列。</code></pre><p><strong>threadFactory</strong>：线程工厂，用于创建线程池中的线程，可以自己实现，默认工厂创建的线程名称为-poolNumber-thread-threadNumber，如：pool-1-thread-10<br><br><strong>handler</strong>: 拒绝策略，当线程池线程达到最大后添加任务不能被执行时的处理策略。拒绝策略有4种实现，当然也可以自己实现（继承RejectExecutionHandle）。</p>
<pre><code>a. AbortPolicy：默认拒绝策略，丢弃这个任务并抛出RejectedExecutionException异常
b. DiscardPolicy：直接丢弃，不做任何处理
c. DiscardOldestPolicy：将工作队列头部元素丢弃（最老的），然后重新提交任务
d. CallerRunsPolicy：主线程直接去执行这个任务，不用等待线程池</code></pre><h4 id="Executors工具类提供了几种ThreadpoolExecutor的创建方法："><a href="#Executors工具类提供了几种ThreadpoolExecutor的创建方法：" class="headerlink" title="Executors工具类提供了几种ThreadpoolExecutor的创建方法："></a>Executors工具类提供了几种ThreadpoolExecutor的创建方法：</h4><h5 id="1-FixedThreadPool"><a href="#1-FixedThreadPool" class="headerlink" title="1. FixedThreadPool"></a>1. FixedThreadPool</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FixedThreadPool的corePoolSize和maximumPoolSize都被设置为同一个参数nThreads<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keepAliveTime被设为0L意味着多余的空闲线程会被立即终止<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列容量为Integer.MAX_VALUE）。这意味着当线程池中的线程数达到corePoolSize时，新任务会被放入工作队列，因此线程池中的线程不会超过核心线程数。所以此时maximumPoolSize和keepAliveTime都是无效参数，并且只要线程池在运行中便不会拒绝任务。</p>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}</code></pre><h5 id="2-SingleThreadExecutor"><a href="#2-SingleThreadExecutor" class="headerlink" title="2. SingleThreadExecutor"></a>2. SingleThreadExecutor</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SingleThreadExecutor是一个使用单个worker线程的Executor，它的核心线程数和最大线程数都被设为1，相当于单线程的FixedThreadPool。</p>
<pre><code>public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}</code></pre><h5 id="3-CachedThreadPool"><a href="#3-CachedThreadPool" class="headerlink" title="3. CachedThreadPool"></a>3. CachedThreadPool</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CachedThreadPool是一个会根据需要创建新线程的线程池，它的corePoolSize为0，意味着核心线程为空。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keepAliveTime被设为60L意味着多余的空闲线程会在空闲60s后被终止。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用没有容量的SynchronousQueue作为工作队列，每次offer操作必须等待另一个take操作，反之亦然，SynchronousQueue就像一个门框（门框上不可以站人）。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最大线程数为Integer.MAX_VALUE，意味着当主线程提交任务速度高于线程池中的线程处理速度时，会无限制的创建新线程。极端情况下，会因为创建过多的线程耗尽CPU和内存资源。</p>
<pre><code>public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}</code></pre><h2 id="2-线程池工作原理"><a href="#2-线程池工作原理" class="headerlink" title="2 线程池工作原理"></a>2 线程池工作原理</h2><pre><code>1. 当一个任务被提交时，线程池会判断核心线程数量是否达到最大，如果没有则会通过线程工厂创建一个新的线程来执行任务；如果达到最大则执行步骤2.
2. 尝试将任务放入工作队列，如果成功加入工作队列，当有工作线程空闲时会去工作队列中获取一个任务来执行；如果加入失败则执行步骤3.
3. 判断线程数量是否已达到最大线程数量，如果没有则会通过线程工厂创建一个新的线程来执行任务；如果已达到最大线程数，则执行拒绝策略   </code></pre><p><img src="ThreadPool.jpg" alt="image"></p>
<h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3 源码分析"></a>3 源码分析</h2><h3 id="3-1-核心静态变量及方法"><a href="#3-1-核心静态变量及方法" class="headerlink" title="3.1 核心静态变量及方法"></a>3.1 核心静态变量及方法</h3><pre><code>//高3位表示运行的状态，低29未表示线程池中运行的线程数量。
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
//Integer的大小为32，Integer.SIZE - 3 = 29
private static final int COUNT_BITS = Integer.SIZE - 3;
//1左移29位后减1，高3位全为0，低29位全为1
private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;

// runState is stored in the high-order bits
//高3位：111 【-1的二进制为32位全为1（取反加1），左移29位后高3位为111】
private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;
//高3位：000
private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;
//高3位: 001
private static final int STOP       =  1 &lt;&lt; COUNT_BITS;
//高3位：010
private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;
//高3位：011
private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;

// Packing and unpacking ctl
// CAPACITY取反后高3位全为1，低29位全为0，与运算后c的低29位全为0，保留高3位获取runState
private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }
// CAPACITY高3位全为0，低29位全为1，与运算后c的高3位全为0，保留低29位获取线程数量
private static int workerCountOf(int c)  { return c &amp; CAPACITY; }
private static int ctlOf(int rs, int wc) { return rs | wc; }</code></pre><h3 id="3-2-入口方法（execute）"><a href="#3-2-入口方法（execute）" class="headerlink" title="3.2 入口方法（execute）"></a>3.2 入口方法（execute）</h3><ol>
<li><p>如果工作线程未达到核心线程数，直接创建一个工作线程来执行任务，创建失败则继续执行下一步。</p>
</li>
<li><p>如果线程池正在运行中并且将任务加入工作队列成功，则进行安全检查，虽然加入工作队列成功，但是保不齐其他调用者或者线程此时会修改线程池状态，那么此时我们就需要将任务再进行必要的移除，这是考虑复杂情况的一种安全机制的保障。</p>
</li>
<li><p>如果加入队列失败，工作线程未达到最大线程数，则创建一个新的线程来执行任务，工作线程已达到最大线程数则执行拒绝策略</p>
<p> public void execute(Runnable command) {</p>
<pre><code>if (command == null)
    throw new NullPointerException();
//高3位表示运行的状态，低29未表示线程池中运行的线程数量。
int c = ctl.get();
//根据低29位获取线程数
if (workerCountOf(c) &lt; corePoolSize) {
    //如果工作线程数量小于核心线程数，尝试创建新的worker线程来执行任务
    if (addWorker(command, true))
        return;
    //如果失败可能是在addWorker时ctl发生改变（核心线程数达到最大），所以重新获取值
    c = ctl.get();
}
//如果线程池正在运行中并且将任务加入工作队列成功
if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
    int recheck = ctl.get();
    //如果此刻线程池已不在运行并且任务从队列移除成功，执行拒绝策略
    if (! isRunning(recheck) &amp;&amp; remove(command))
        reject(command);
    //如果此刻线程池还在运行，但是工作线程数量为0，则增加一个空的工作线程
    else if (workerCountOf(recheck) == 0)
        addWorker(null, false);
}
//如果加入队列失败，工作线程未达到最大线程数，则创建一个新的线程来执行任务
else if (!addWorker(command, false))
    //工作线程已达到最大线程数，执行拒绝策略
    reject(command);</code></pre><p> }</p>
</li>
</ol>
<h3 id="3-3-增加工作线程（addWorker）"><a href="#3-3-增加工作线程（addWorker）" class="headerlink" title="3.3 增加工作线程（addWorker）"></a>3.3 增加工作线程（addWorker）</h3><p>首先通过CAS操作增加工作线程数量，增加成功后实例化一个工作线程用来执行任务，然后将工作线程加入works，因为works实际上是一个非线程安全的容器（HashSet），所以通过可重入锁（ReentrantLock）来保证了线程安全问题，防止多个任务同时提交导致works计算不准确，如果添加成功则将该工作线程启动。</p>
<pre><code>private boolean addWorker(Runnable firstTask, boolean core) {
    //continue retry; 可以使retry：后面的代码块重新执行
    //break retry; 可以使retry：后面的代码块终止执行，不管有多少层循环嵌套
    retry:
    for (;;) {
        //高3位表示运行的状态，低29未表示线程池中运行的线程数量。
        int c = ctl.get();
        //获取线程池的运行状态
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        if (rs &gt;= SHUTDOWN &amp;&amp;
            ! (rs == SHUTDOWN &amp;&amp;
               firstTask == null &amp;&amp;
               ! workQueue.isEmpty()))
            return false;

        for (;;) {
            //获取工作线程数量
            int wc = workerCountOf(c);
            //如果工作线程数超过限制，则返回添加失败
            if (wc &gt;= CAPACITY ||
                wc &gt;= (core ? corePoolSize : maximumPoolSize))
                return false;
            //通过CAS机制增加工作线程数，成功则直接跳出循环
            if (compareAndIncrementWorkerCount(c))
                break retry;
            //如果CAS操作失败，则说明其他调用者或者线程修改了线程池数据，需要重新读取
            c = ctl.get();  // Re-read ctl
            //如果当前线程池状态已经发生了改变，则从最外层循环开始重新执行
            if (runStateOf(c) != rs)
                continue retry;
            // 否则继续当前循环
        }
    }
    //工作线程启动状态
    boolean workerStarted = false;
    //工作线程添加状态
    boolean workerAdded = false;
    //工作线程引用
    Worker w = null;
    try {
        //实例化一个工作线程用于执行任务
        w = new Worker(firstTask);
        //取工作线程中的线程
        final Thread t = w.thread;
        if (t != null) {
            //获取可重入锁
            final ReentrantLock mainLock = this.mainLock;
            //加锁，防止多个线程同时提交任务导致works计算不准确，因为works实际上使用HashSet存储的，非线程安全的
            mainLock.lock();
            try {
                // 获取线程池运行状态
                int rs = runStateOf(ctl.get());

                //如果线程池处于运行状态
                if (rs &lt; SHUTDOWN ||
                    //或者终止状态并且任务为空
                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) {
                    //如果该线程已运行，则抛出IllegalThreadStateException异常
                    if (t.isAlive())
                        throw new IllegalThreadStateException();
                    //将新建的工作线程加入works
                    workers.add(w);
                    int s = workers.size();
                    if (s &gt; largestPoolSize)
                        largestPoolSize = s;
                    //调整工作线程添加状态为true
                    workerAdded = true;
                }
            } finally {
                //释放锁
                mainLock.unlock();
            }
            //如果工作线程已添加，则启动该线程，并将工作线程启动状态改为true
            if (workerAdded) {
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        //如果工作线程未启动，执行添加失败逻辑
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}</code></pre>
            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2019年07月10日 17:39</p>
        <p>原始链接： <a class="post-url" href="/J.U.C/ThreadPoolExecutor/" title="ThreadPoolExecutor">despacitoyo.github.io/J.U.C/ThreadPoolExecutor/</a></p>
        <footer>
            <a href="despacitoyo.github.io">
                <img src="/images/logo.png" alt="DespacitoYo">
                DespacitoYo
            </a>
        </footer>
    </div>
</div>

      
        
            

        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=despacitoyo.github.io/J.U.C/ThreadPoolExecutor/&title=《ThreadPoolExecutor》 — DespacitoYo&pic=https://despacitoyo.github.io/J.U.C/ThreadPoolExecutor/ThreadPool.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=despacitoyo.github.io/J.U.C/ThreadPoolExecutor/&title=《ThreadPoolExecutor》 — DespacitoYo&source=" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=despacitoyo.github.io/J.U.C/ThreadPoolExecutor/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《ThreadPoolExecutor》 — DespacitoYo&url=despacitoyo.github.io/J.U.C/ThreadPoolExecutor/&via=despacitoyo.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=despacitoyo.github.io/J.U.C/ThreadPoolExecutor/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=despacitoyo.github.io/J.U.C/ThreadPoolExecutor/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-创建线程池（ThreadPoolExecutor）"><span class="post-toc-text">1 创建线程池（ThreadPoolExecutor）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Executors工具类提供了几种ThreadpoolExecutor的创建方法："><span class="post-toc-text">Executors工具类提供了几种ThreadpoolExecutor的创建方法：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1-FixedThreadPool"><span class="post-toc-text">1. FixedThreadPool</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-SingleThreadExecutor"><span class="post-toc-text">2. SingleThreadExecutor</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3-CachedThreadPool"><span class="post-toc-text">3. CachedThreadPool</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-线程池工作原理"><span class="post-toc-text">2 线程池工作原理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-源码分析"><span class="post-toc-text">3 源码分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-核心静态变量及方法"><span class="post-toc-text">3.1 核心静态变量及方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-入口方法（execute）"><span class="post-toc-text">3.2 入口方法（execute）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-增加工作线程（addWorker）"><span class="post-toc-text">3.3 增加工作线程（addWorker）</span></a></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/J.U.C/ScheduledThreadPoolExecutor/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          ScheduledThreadPoolExecutor
        
      </span>
    </a>
  
  
</nav>



    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2019 DespacitoYo<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "despacitoyo.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 0
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            
        </div>
        <div id="sidebar-menu-box-tags">
            
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>
<script src="/js/search.js"></script>
<script src="/js/main.js"></script>


  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  <script src="/js/particles.js"></script>







  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  <script src="/js/animate.js"></script>


  <script src="/js/pop-img.js"></script>
  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>